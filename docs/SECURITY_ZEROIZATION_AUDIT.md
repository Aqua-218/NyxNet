# Zeroization Audit (Phase 1)

対象: `nyx-crypto` 内の機密鍵/共有秘密/セッション鍵構造体。

## カバレッジ一覧

| 種別 | 構造体 / 型 | メカニズム | 備考 |
|------|--------------|------------|------|
| セッション鍵 | `noise::SessionKey` | `#[derive(ZeroizeOnDrop)]` | 32 bytes 固定長配列。 |
| 転送コンテキスト鍵 | `aead::EncryptionContext` 内 `SessionKey` | `ZeroizeOnDrop` (構造体派生) | Drop でキー自動ゼロ化。 |
| Noise トランスポート鍵 | `noise::NoiseTransport` | カスタム `Drop` + `Zeroize` | `send_key` / `recv_key` 内配列を明示ゼロ化。 |
| HPKE 共有秘密 | `hpke::SharedSecret` | `ZeroizeOnDrop` + 明示 `Drop` | Vec バッファ内容 zeroize。 |
| ハイブリッド秘密鍵 | `hybrid::HybridSecretKey` | カスタム `Drop` | `x25519_sk` / `pq_sk` zeroize。 |
| PCR 再鍵処理 | `pcr_rekey` 関数 | 処理内で旧 `SessionKey` 配列 zeroize | Forward secrecy 確保。 |

## 未完了 / 次フェーズ

- Miri/Valgrind を用いた実行時メモリ残留検査 (Phase 2)。
- Feature `hybrid`, `hpke`, `kyber` 有効組合せでのマトリクス検証。
- `NoiseHandshake` 過程中一時バッファ (派生鍵素材) の確実な即時ゼロ化確認。

## テスト

`tests/zeroization_audit.rs` にて基礎的コンパイル監査と (feature 活性時) `HybridSecretKey` Drop 呼び出し確認。
実メモリ残留検査は unsafe 禁止方針のため導入せず、CI 拡張で対応予定。

## ポリシー

1. 機密データは固定長配列 or `Vec<u8>` を保持する場合、`ZeroizeOnDrop` もしくは明示 `Drop` 実装でゼロ化。
2. 公開鍵や長期で公開前提のメタデータはゼロ化不要。ただし再利用不要なバッファは極力スコープ終了時に破棄。
3. Forward secrecy: 再鍵 (PCR) 実行時に旧キーは直ちに `zeroize()`。

## セキュリティ影響

実装によりクラッシュダンプ/ヒープスキャンからの平文鍵流出リスクを軽減。Miri 検査導入後は解放後アクセスで再び鍵が観測されないことを継続検証予定。

---
Phase 1 完了: 2025-08-10
Maintainer: (auto-generated by assistant)# Zeroization Audit (NyxNet)

Date: 2025-08-10

## Scope
Survey of cryptographic / secret-bearing structures ensuring memory is wiped (zeroized) after use to reduce risk of key material lingering in process memory.

## Method
`grep -R "zeroize" nyx-crypto/src` (automated in tooling) plus manual inspection of key modules:
- `nyx-crypto/src/noise.rs`
- `nyx-crypto/src/lib.rs`
- `nyx-crypto/src/pcr.rs`
- `nyx-crypto/src/keystore.rs`

## Findings
| Component | Type / Struct | Mechanism | Status |
|----------|---------------|-----------|--------|
| Session Keys | `SessionKey` (noise.rs) | `#[derive(ZeroizeOnDrop)]` | OK |
| PCR Rekey | temporary old key buffer | `zeroize()` before return | OK |
| Hybrid Handshake | concatenated secret buffer `concat` | manual `zeroize()` after KDF | OK |
| Rekey Function | old key array | manual zeroize | OK |
| Keystore | (future persistent storage) | uses `Zeroizing` wrapper for in-memory secret exposure | OK (wrapper present) |

## Gaps / TODO
- Confirm any additional secret structs introduced in future (e.g. HPKE context) also derive `ZeroizeOnDrop`.
- Add fuzz test ensuring no accidental Debug printing of raw key bytes (non urgent).
- Evaluate memory locking (mlock/VirtualLock) for high-value long-lived keys (out of scope for v1.0).

## Test Suggestion (Future)
Introduce a feature-gated unsafe memory scan test that allocates a key, drops it, then scans its allocation region for non-zero bytes (heuristic; may be flaky, so keep behind `zeroize_test` feature).

## Conclusion
Current key material paths implement zeroization at destruction or immediately after use. No unprotected long-lived secret buffers identified.
