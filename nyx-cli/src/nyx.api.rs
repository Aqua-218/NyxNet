// This file is @generated by prost-build.
/// Extended NodeInfo with comprehensive daemon status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeInfo {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub uptime_sec: u32,
    #[prost(uint64, tag = "4")]
    pub bytes_in: u64,
    #[prost(uint64, tag = "5")]
    pub bytes_out: u64,
    /// Extended fields for v1.0
    #[prost(uint32, tag = "6")]
    pub pid: u32,
    #[prost(uint32, tag = "7")]
    pub active_streams: u32,
    #[prost(uint32, tag = "8")]
    pub connected_peers: u32,
    #[prost(string, repeated, tag = "9")]
    pub mix_routes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Performance metrics
    #[prost(message, optional, tag = "10")]
    pub performance: ::core::option::Option<PerformanceMetrics>,
    /// System resource usage
    #[prost(message, optional, tag = "11")]
    pub resources: ::core::option::Option<ResourceUsage>,
    /// Network topology info
    #[prost(message, optional, tag = "12")]
    pub topology: ::core::option::Option<NetworkTopology>,
}
/// Performance metrics for the daemon
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerformanceMetrics {
    /// packets/sec
    #[prost(double, tag = "1")]
    pub cover_traffic_rate: f64,
    /// milliseconds
    #[prost(double, tag = "2")]
    pub avg_latency_ms: f64,
    /// 0.0-1.0
    #[prost(double, tag = "3")]
    pub packet_loss_rate: f64,
    /// 0.0-1.0
    #[prost(double, tag = "4")]
    pub bandwidth_utilization: f64,
    /// 0.0-1.0
    #[prost(double, tag = "5")]
    pub cpu_usage: f64,
    /// megabytes
    #[prost(double, tag = "6")]
    pub memory_usage_mb: f64,
    #[prost(uint64, tag = "7")]
    pub total_packets_sent: u64,
    #[prost(uint64, tag = "8")]
    pub total_packets_received: u64,
    #[prost(uint64, tag = "9")]
    pub retransmissions: u64,
    /// 0.0-1.0
    #[prost(double, tag = "10")]
    pub connection_success_rate: f64,
}
/// System resource usage
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceUsage {
    #[prost(uint64, tag = "1")]
    pub memory_rss_bytes: u64,
    #[prost(uint64, tag = "2")]
    pub memory_vms_bytes: u64,
    #[prost(double, tag = "3")]
    pub cpu_percent: f64,
    #[prost(uint32, tag = "4")]
    pub open_file_descriptors: u32,
    #[prost(uint32, tag = "5")]
    pub thread_count: u32,
    #[prost(uint64, tag = "6")]
    pub network_bytes_sent: u64,
    #[prost(uint64, tag = "7")]
    pub network_bytes_received: u64,
}
/// Network topology information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkTopology {
    #[prost(message, repeated, tag = "1")]
    pub peers: ::prost::alloc::vec::Vec<PeerInfo>,
    #[prost(message, repeated, tag = "2")]
    pub paths: ::prost::alloc::vec::Vec<PathInfo>,
    #[prost(uint32, tag = "3")]
    pub total_nodes_known: u32,
    #[prost(uint32, tag = "4")]
    pub reachable_nodes: u32,
    #[prost(string, tag = "5")]
    pub current_region: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub available_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Information about connected peers
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerInfo {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub latency_ms: f64,
    #[prost(double, tag = "4")]
    pub bandwidth_mbps: f64,
    /// "connected", "connecting", "disconnected"
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub last_seen: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag = "7")]
    pub connection_count: u32,
    #[prost(string, tag = "8")]
    pub region: ::prost::alloc::string::String,
}
/// Information about network paths
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathInfo {
    #[prost(uint32, tag = "1")]
    pub path_id: u32,
    /// node IDs in order
    #[prost(string, repeated, tag = "2")]
    pub hops: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "3")]
    pub total_latency_ms: f64,
    #[prost(double, tag = "4")]
    pub min_bandwidth_mbps: f64,
    /// "active", "backup", "failed"
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub packet_count: u32,
    #[prost(double, tag = "7")]
    pub success_rate: f64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Stream management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenRequest {
    #[prost(string, tag = "1")]
    pub stream_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<StreamOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOptions {
    #[prost(uint32, tag = "1")]
    pub buffer_size: u32,
    #[prost(uint32, tag = "2")]
    pub timeout_ms: u32,
    #[prost(bool, tag = "3")]
    pub multipath: bool,
    #[prost(uint32, tag = "4")]
    pub max_paths: u32,
    /// "latency_weighted", "random", "lowest_latency", "load_balance"
    #[prost(string, tag = "5")]
    pub path_strategy: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub auto_reconnect: bool,
    #[prost(uint32, tag = "7")]
    pub max_retry_attempts: u32,
    #[prost(bool, tag = "8")]
    pub compression: bool,
    #[prost(string, tag = "9")]
    pub cipher_suite: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamResponse {
    #[prost(uint32, tag = "1")]
    pub stream_id: u32,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub target_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub initial_stats: ::core::option::Option<StreamStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamId {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
/// Detailed stream statistics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamStats {
    #[prost(uint32, tag = "1")]
    pub stream_id: u32,
    #[prost(string, tag = "2")]
    pub target_address: ::prost::alloc::string::String,
    /// "idle", "open", "half_closed_local", "half_closed_remote", "closed"
    #[prost(string, tag = "3")]
    pub state: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub last_activity: ::core::option::Option<::prost_types::Timestamp>,
    /// Traffic statistics
    #[prost(uint64, tag = "6")]
    pub bytes_sent: u64,
    #[prost(uint64, tag = "7")]
    pub bytes_received: u64,
    #[prost(uint64, tag = "8")]
    pub packets_sent: u64,
    #[prost(uint64, tag = "9")]
    pub packets_received: u64,
    #[prost(uint64, tag = "10")]
    pub retransmissions: u64,
    /// Performance metrics
    #[prost(double, tag = "11")]
    pub avg_rtt_ms: f64,
    #[prost(double, tag = "12")]
    pub min_rtt_ms: f64,
    #[prost(double, tag = "13")]
    pub max_rtt_ms: f64,
    #[prost(double, tag = "14")]
    pub bandwidth_mbps: f64,
    #[prost(double, tag = "15")]
    pub packet_loss_rate: f64,
    /// Path information for multipath streams
    #[prost(message, repeated, tag = "16")]
    pub paths: ::prost::alloc::vec::Vec<StreamPathStats>,
    /// Error statistics
    #[prost(uint32, tag = "17")]
    pub connection_errors: u32,
    #[prost(uint32, tag = "18")]
    pub timeout_errors: u32,
    #[prost(string, tag = "19")]
    pub last_error: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "20")]
    pub last_error_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Per-path statistics for multipath streams
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamPathStats {
    #[prost(uint32, tag = "1")]
    pub path_id: u32,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub rtt_ms: f64,
    #[prost(double, tag = "4")]
    pub bandwidth_mbps: f64,
    #[prost(uint64, tag = "5")]
    pub bytes_sent: u64,
    #[prost(uint64, tag = "6")]
    pub bytes_received: u64,
    #[prost(uint32, tag = "7")]
    pub packet_count: u32,
    #[prost(double, tag = "8")]
    pub success_rate: f64,
}
/// Event system
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventFilter {
    /// "stream", "connection", "error", "performance", "system"
    #[prost(string, repeated, tag = "1")]
    pub types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// filter by specific stream IDs
    #[prost(uint32, repeated, tag = "2")]
    pub stream_ids: ::prost::alloc::vec::Vec<u32>,
    /// "debug", "info", "warn", "error"
    #[prost(string, tag = "3")]
    pub severity: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub detail: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub severity: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Event-specific data
    #[prost(oneof = "event::EventData", tags = "6, 7, 8, 9")]
    pub event_data: ::core::option::Option<event::EventData>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    /// Event-specific data
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EventData {
        #[prost(message, tag = "6")]
        StreamEvent(super::StreamEvent),
        #[prost(message, tag = "7")]
        ConnectionEvent(super::ConnectionEvent),
        #[prost(message, tag = "8")]
        PerformanceEvent(super::PerformanceEvent),
        #[prost(message, tag = "9")]
        SystemEvent(super::SystemEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEvent {
    #[prost(uint32, tag = "1")]
    pub stream_id: u32,
    /// "opened", "closed", "error", "reconnecting", "data_sent", "data_received"
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub target_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub stats: ::core::option::Option<StreamStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionEvent {
    #[prost(string, tag = "1")]
    pub peer_id: ::prost::alloc::string::String,
    /// "connected", "disconnected", "handshake_complete", "authentication_failed"
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub latency_ms: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerformanceEvent {
    /// "latency_spike", "bandwidth_drop", "packet_loss_high", "cpu_high"
    #[prost(string, tag = "1")]
    pub metric: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub value: f64,
    #[prost(double, tag = "3")]
    pub threshold: f64,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemEvent {
    /// "daemon", "transport", "crypto", "mix", "fec"
    #[prost(string, tag = "1")]
    pub component: ::prost::alloc::string::String,
    /// "started", "stopped", "error", "warning", "config_reload"
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "4")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Configuration management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigUpdate {
    #[prost(map = "string, string", tag = "1")]
    pub settings: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "2")]
    pub restart_required: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub validation_errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Real-time statistics streaming
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsRequest {
    /// update interval in milliseconds
    #[prost(uint32, tag = "1")]
    pub interval_ms: u32,
    /// specific metrics to include
    #[prost(string, repeated, tag = "2")]
    pub metrics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsUpdate {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub node_info: ::core::option::Option<NodeInfo>,
    #[prost(message, repeated, tag = "3")]
    pub stream_stats: ::prost::alloc::vec::Vec<StreamStats>,
    #[prost(map = "string, double", tag = "4")]
    pub custom_metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
}
/// Health check
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthRequest {
    #[prost(bool, tag = "1")]
    pub include_details: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    /// "healthy", "degraded", "unhealthy"
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub checks: ::prost::alloc::vec::Vec<HealthCheck>,
    #[prost(message, optional, tag = "3")]
    pub checked_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheck {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub response_time_ms: f64,
}
/// Path management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathRequest {
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub hops: u32,
    /// "latency_optimized", "bandwidth_optimized", "reliability_optimized"
    #[prost(string, tag = "3")]
    pub strategy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathResponse {
    /// ordered list of node IDs
    #[prost(string, repeated, tag = "1")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "2")]
    pub estimated_latency_ms: f64,
    #[prost(double, tag = "3")]
    pub estimated_bandwidth_mbps: f64,
    #[prost(double, tag = "4")]
    pub reliability_score: f64,
}
/// Generated client implementations.
pub mod nyx_control_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service definition with comprehensive API
    #[derive(Debug, Clone)]
    pub struct NyxControlClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NyxControlClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NyxControlClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NyxControlClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NyxControlClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Basic node information
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::NodeInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/GetInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "GetHealth"));
            self.inner.unary(req, path, codec).await
        }
        /// Stream management
        pub async fn open_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenRequest>,
        ) -> std::result::Result<tonic::Response<super::StreamResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/OpenStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "OpenStream"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn close_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamId>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/CloseStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "CloseStream"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_stream_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamId>,
        ) -> std::result::Result<tonic::Response<super::StreamStats>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/GetStreamStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "GetStreamStats"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_streams(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamStats>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/ListStreams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "ListStreams"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Event subscription
        pub async fn subscribe_events(
            &mut self,
            request: impl tonic::IntoRequest<super::EventFilter>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Event>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/SubscribeEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "SubscribeEvents"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Real-time statistics
        pub async fn subscribe_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::StatsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StatsUpdate>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/SubscribeStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "SubscribeStats"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Configuration management
        pub async fn update_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfigUpdate>,
        ) -> std::result::Result<tonic::Response<super::ConfigResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/UpdateConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "UpdateConfig"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn reload_config(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::ConfigResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/ReloadConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "ReloadConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Path management
        pub async fn build_path(
            &mut self,
            request: impl tonic::IntoRequest<super::PathRequest>,
        ) -> std::result::Result<tonic::Response<super::PathResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/BuildPath",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "BuildPath"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_paths(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PathInfo>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/GetPaths",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "GetPaths"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Network topology
        pub async fn get_topology(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkTopology>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/GetTopology",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "GetTopology"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_peers(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PeerInfo>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/nyx.api.NyxControl/GetPeers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("nyx.api.NyxControl", "GetPeers"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
